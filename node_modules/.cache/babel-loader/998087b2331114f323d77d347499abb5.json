{"ast":null,"code":"(function () {\n  'use strict'; // desiredOffset - page offset to scroll to\n  // speed - duration of the scroll per 1000px\n\n  function __ANIMATE_SCROLL_TO(desiredOffset) {\n    var userOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    var options = {\n      speed: 500,\n      minDuration: 250,\n      maxDuration: 1500,\n      cancelOnUserAction: true,\n      element: window,\n      horizontal: false,\n      onComplete: undefined,\n      passive: true,\n      offset: 0\n    };\n    var optionsKeys = Object.keys(options); // Override default options\n\n    for (var i = 0; i < optionsKeys.length; i++) {\n      var key = optionsKeys[i];\n\n      if (typeof userOptions[key] !== 'undefined') {\n        options[key] = userOptions[key];\n      }\n    }\n\n    if (!options.cancelOnUserAction && options.passive) {\n      options.passive = false;\n\n      if (userOptions.passive) {\n        console && console.warn('animated-scroll-to:\\n \"passive\" was set to \"false\" to prevent errors, ' + 'as using \"cancelOnUserAction: false\" doesn\\'t work with passive events.');\n      }\n    }\n\n    if (desiredOffset instanceof HTMLElement) {\n      if (userOptions.element && userOptions.element instanceof HTMLElement) {\n        if (options.horizontal) {\n          desiredOffset = desiredOffset.getBoundingClientRect().left + userOptions.element.scrollLeft - userOptions.element.getBoundingClientRect().left;\n        } else {\n          desiredOffset = desiredOffset.getBoundingClientRect().top + userOptions.element.scrollTop - userOptions.element.getBoundingClientRect().top;\n        }\n      } else if (options.horizontal) {\n        var scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        desiredOffset = scrollLeft + desiredOffset.getBoundingClientRect().left;\n      } else {\n        var scrollTop = window.scrollY || document.documentElement.scrollTop;\n        desiredOffset = scrollTop + desiredOffset.getBoundingClientRect().top;\n      }\n    } // Add additonal user offset\n\n\n    desiredOffset += options.offset;\n    options.isWindow = options.element === window;\n    var initialScrollPosition = null;\n    var initialAxisScollPosition = 0;\n    var maxScroll = null;\n\n    if (options.isWindow) {\n      if (options.horizontal) {\n        // get cross browser scroll positions\n        initialScrollPosition = window.scrollX || document.documentElement.scrollLeft;\n        initialAxisScollPosition = window.scrollY || document.documentElement.scrollTop; // cross browser document height minus window height\n\n        maxScroll = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;\n      } else {\n        // get cross browser scroll positions\n        initialScrollPosition = window.scrollY || document.documentElement.scrollTop;\n        initialAxisScollPosition = window.scrollX || document.documentElement.scrollLeft; // cross browser document width minus window width\n\n        maxScroll = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;\n      }\n    } else {\n      // DOM element\n      if (options.horizontal) {\n        initialScrollPosition = options.element.scrollLeft;\n        maxScroll = options.element.scrollWidth - options.element.clientWidth;\n      } else {\n        initialScrollPosition = options.element.scrollTop;\n        maxScroll = options.element.scrollHeight - options.element.clientHeight;\n      }\n    } // If the scroll position is greater than maximum available scroll\n\n\n    if (desiredOffset > maxScroll) {\n      desiredOffset = maxScroll;\n    } // Calculate diff to scroll\n\n\n    var diff = desiredOffset - initialScrollPosition; // Do nothing if the page is already there\n\n    if (diff === 0) {\n      // Execute callback if there is any\n      if (options.onComplete && typeof options.onComplete === 'function') {\n        options.onComplete(false);\n      }\n\n      return;\n    } // Calculate duration of the scroll\n\n\n    var duration = Math.abs(Math.round(diff / 1000 * options.speed)); // Set minimum and maximum duration\n\n    if (duration < options.minDuration) {\n      duration = options.minDuration;\n    } else if (duration > options.maxDuration) {\n      duration = options.maxDuration;\n    }\n\n    var startingTime = Date.now(); // Request animation frame ID\n\n    var requestID = null; // Method handler\n\n    var handleUserEvent = null;\n    var userEventOptions = {\n      passive: options.passive\n    };\n\n    if (options.cancelOnUserAction) {\n      // Set handler to cancel scroll on user action\n      handleUserEvent = function () {\n        removeListeners();\n        cancelAnimationFrame(requestID); // Animation is canceled, execute callback if there is any\n\n        if (options.onComplete && typeof options.onComplete === 'function') {\n          options.onComplete(true);\n        }\n      };\n\n      window.addEventListener('keydown', handleUserEvent, userEventOptions);\n      window.addEventListener('mousedown', handleUserEvent, userEventOptions);\n    } else {\n      // Set handler to prevent user actions while scroll is active\n      handleUserEvent = function (e) {\n        e.preventDefault();\n      };\n\n      options.element.addEventListener('scroll', handleUserEvent, userEventOptions);\n    }\n\n    options.element.addEventListener('wheel', handleUserEvent, userEventOptions);\n    options.element.addEventListener('touchstart', handleUserEvent, userEventOptions);\n\n    var removeListeners = function () {\n      options.element.removeEventListener('wheel', handleUserEvent, userEventOptions);\n      options.element.removeEventListener('touchstart', handleUserEvent, userEventOptions);\n\n      if (options.cancelOnUserAction) {\n        window.removeEventListener('keydown', handleUserEvent, userEventOptions);\n        window.removeEventListener('mousedown', handleUserEvent, userEventOptions);\n      } else {\n        options.element.removeEventListener('scroll', handleUserEvent, userEventOptions);\n      }\n    };\n\n    var step = function () {\n      var timeDiff = Date.now() - startingTime;\n      var t = timeDiff / duration - 1;\n      var easing = t * t * t + 1;\n      var scrollPosition = Math.round(initialScrollPosition + diff * easing);\n\n      var doScroll = function (position) {\n        if (options.isWindow) {\n          if (options.horizontal) {\n            options.element.scrollTo(position, initialAxisScollPosition);\n          } else {\n            options.element.scrollTo(initialAxisScollPosition, position);\n          }\n        } else if (options.horizontal) {\n          options.element.scrollLeft = position;\n        } else {\n          options.element.scrollTop = position;\n        }\n      };\n\n      if (timeDiff < duration && scrollPosition !== desiredOffset) {\n        // If scroll didn't reach desired offset or time is not elapsed\n        // Scroll to a new position\n        // And request a new step\n        doScroll(scrollPosition);\n        requestID = requestAnimationFrame(step);\n      } else {\n        // If the time elapsed or we reached the desired offset\n        // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n        // Clear animation frame to be sure\n        doScroll(desiredOffset);\n        cancelAnimationFrame(requestID); // Remove listeners\n\n        removeListeners(); // Animation is complete, execute callback if there is any\n\n        if (options.onComplete && typeof options.onComplete === 'function') {\n          options.onComplete(false);\n        }\n      }\n    }; // Start animating scroll\n\n\n    requestID = requestAnimationFrame(step);\n  }\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      module.exports = __ANIMATE_SCROLL_TO;\n      exports = module.exports;\n    }\n\n    exports.default = __ANIMATE_SCROLL_TO;\n  } else if (window) {\n    window.animateScrollTo = __ANIMATE_SCROLL_TO;\n  }\n}).call(this);","map":{"version":3,"sources":["/Users/jaredricardo/Desktop/apps/portfolio/node_modules/animated-scroll-to/animated-scroll-to.js"],"names":["__ANIMATE_SCROLL_TO","desiredOffset","userOptions","arguments","length","undefined","options","speed","minDuration","maxDuration","cancelOnUserAction","element","window","horizontal","onComplete","passive","offset","optionsKeys","Object","keys","i","key","console","warn","HTMLElement","getBoundingClientRect","left","scrollLeft","top","scrollTop","scrollX","document","documentElement","scrollY","isWindow","initialScrollPosition","initialAxisScollPosition","maxScroll","Math","max","body","scrollWidth","offsetWidth","clientWidth","innerWidth","scrollHeight","offsetHeight","clientHeight","innerHeight","diff","duration","abs","round","startingTime","Date","now","requestID","handleUserEvent","userEventOptions","removeListeners","cancelAnimationFrame","addEventListener","e","preventDefault","removeEventListener","step","timeDiff","t","easing","scrollPosition","doScroll","position","scrollTo","requestAnimationFrame","exports","module","default","animateScrollTo","call"],"mappings":"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","sourcesContent":["(function() {\n  'use strict';\n\n  // desiredOffset - page offset to scroll to\n  // speed - duration of the scroll per 1000px\n  function __ANIMATE_SCROLL_TO(desiredOffset) {\n    var userOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var options = {\n      speed: 500,\n      minDuration: 250,\n      maxDuration: 1500,\n      cancelOnUserAction: true,\n      element: window,\n      horizontal: false,\n      onComplete: undefined,\n      passive: true,\n      offset: 0\n    };\n\n    var optionsKeys = Object.keys(options);\n\n    // Override default options\n    for (var i = 0; i < optionsKeys.length; i++) {\n      var key = optionsKeys[i];\n\n      if (typeof userOptions[key] !== 'undefined') {\n        options[key] = userOptions[key];\n      }\n    }\n\n    if (!options.cancelOnUserAction && options.passive) {\n      options.passive = false;\n      if (userOptions.passive) {\n        console && console.warn(\n          'animated-scroll-to:\\n \"passive\" was set to \"false\" to prevent errors, ' +\n          'as using \"cancelOnUserAction: false\" doesn\\'t work with passive events.')\n      }\n    }\n\n    if (desiredOffset instanceof HTMLElement) {\n      if (userOptions.element && userOptions.element instanceof HTMLElement) {\n        if (options.horizontal) {\n          desiredOffset = (desiredOffset.getBoundingClientRect().left + userOptions.element.scrollLeft)\n            - userOptions.element.getBoundingClientRect().left;\n        } else {\n          desiredOffset = (desiredOffset.getBoundingClientRect().top + userOptions.element.scrollTop)\n            - userOptions.element.getBoundingClientRect().top;\n        }\n      } else if (options.horizontal) {\n        var scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        desiredOffset = scrollLeft + desiredOffset.getBoundingClientRect().left;\n      } else {\n        var scrollTop = window.scrollY || document.documentElement.scrollTop;\n        desiredOffset = scrollTop + desiredOffset.getBoundingClientRect().top;\n      }\n    }\n\n    // Add additonal user offset\n    desiredOffset += options.offset\n\n    options.isWindow = options.element === window;\n\n    var initialScrollPosition = null;\n    var initialAxisScollPosition = 0;\n    var maxScroll = null;\n\n    if (options.isWindow) {\n      if (options.horizontal) {\n        // get cross browser scroll positions\n        initialScrollPosition = window.scrollX || document.documentElement.scrollLeft;\n        initialAxisScollPosition = window.scrollY || document.documentElement.scrollTop;\n        // cross browser document height minus window height\n        maxScroll = Math.max(\n          document.body.scrollWidth, document.documentElement.scrollWidth,\n          document.body.offsetWidth, document.documentElement.offsetWidth,\n          document.body.clientWidth, document.documentElement.clientWidth\n        ) - window.innerWidth;\n      } else {\n        // get cross browser scroll positions\n        initialScrollPosition = window.scrollY || document.documentElement.scrollTop;\n        initialAxisScollPosition = window.scrollX || document.documentElement.scrollLeft;\n        // cross browser document width minus window width\n        maxScroll = Math.max(\n          document.body.scrollHeight, document.documentElement.scrollHeight,\n          document.body.offsetHeight, document.documentElement.offsetHeight,\n          document.body.clientHeight, document.documentElement.clientHeight\n        ) - window.innerHeight;\n      }\n    } else {\n      // DOM element\n      if (options.horizontal) {\n        initialScrollPosition = options.element.scrollLeft;\n        maxScroll = options.element.scrollWidth - options.element.clientWidth;\n      } else {\n        initialScrollPosition = options.element.scrollTop;\n        maxScroll = options.element.scrollHeight - options.element.clientHeight;\n      }\n    }\n\n    // If the scroll position is greater than maximum available scroll\n    if (desiredOffset > maxScroll) {\n      desiredOffset = maxScroll;\n    }\n\n    // Calculate diff to scroll\n    var diff = desiredOffset - initialScrollPosition;\n\n    // Do nothing if the page is already there\n    if (diff === 0) {\n      // Execute callback if there is any\n      if (options.onComplete && typeof options.onComplete === 'function') {\n        options.onComplete(false)\n      }\n\n      return;\n    }\n\n    // Calculate duration of the scroll\n    var duration = Math.abs(Math.round((diff / 1000) * options.speed));\n\n    // Set minimum and maximum duration\n    if (duration < options.minDuration) {\n      duration = options.minDuration;\n    } else if (duration > options.maxDuration) {\n      duration = options.maxDuration;\n    }\n\n    var startingTime = Date.now();\n\n    // Request animation frame ID\n    var requestID = null;\n\n    // Method handler\n    var handleUserEvent = null;\n    var userEventOptions = { passive: options.passive };\n\n    if (options.cancelOnUserAction) {\n      // Set handler to cancel scroll on user action\n      handleUserEvent = function() {\n        removeListeners();\n        cancelAnimationFrame(requestID);\n        \n        // Animation is canceled, execute callback if there is any\n        if (options.onComplete && typeof options.onComplete === 'function') {\n          options.onComplete(true)\n        }\n      };\n      window.addEventListener('keydown', handleUserEvent, userEventOptions);\n      window.addEventListener('mousedown', handleUserEvent, userEventOptions);\n    } else {\n      // Set handler to prevent user actions while scroll is active\n      handleUserEvent = function(e) { e.preventDefault(); };\n      options.element.addEventListener('scroll', handleUserEvent, userEventOptions);\n    }\n\n    options.element.addEventListener('wheel', handleUserEvent, userEventOptions);\n    options.element.addEventListener('touchstart', handleUserEvent, userEventOptions);\n\n    var removeListeners = function () {\n      options.element.removeEventListener('wheel', handleUserEvent, userEventOptions);\n      options.element.removeEventListener('touchstart', handleUserEvent, userEventOptions);\n\n      if (options.cancelOnUserAction) {\n        window.removeEventListener('keydown', handleUserEvent, userEventOptions);\n        window.removeEventListener('mousedown', handleUserEvent, userEventOptions);\n      } else {\n        options.element.removeEventListener('scroll', handleUserEvent, userEventOptions);\n      }\n    };\n\n    var step = function () {\n      var timeDiff = Date.now() - startingTime;\n      var t = (timeDiff / duration) - 1;\n      var easing = t * t * t + 1;\n      var scrollPosition = Math.round(initialScrollPosition + (diff * easing));\n\n      var doScroll = function(position) {\n        if (options.isWindow) {\n          if (options.horizontal) {\n            options.element.scrollTo(position, initialAxisScollPosition);\n          } else {\n            options.element.scrollTo(initialAxisScollPosition, position);\n          }\n        } else if (options.horizontal) {\n          options.element.scrollLeft = position;\n        } else {\n          options.element.scrollTop = position;\n        }\n      }\n\n      if (timeDiff < duration && scrollPosition !== desiredOffset) {\n        // If scroll didn't reach desired offset or time is not elapsed\n        // Scroll to a new position\n        // And request a new step\n        doScroll(scrollPosition);\n\n        requestID = requestAnimationFrame(step);\n      } else {\n        // If the time elapsed or we reached the desired offset\n        // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n        // Clear animation frame to be sure\n        doScroll(desiredOffset);\n\n        cancelAnimationFrame(requestID);\n\n        // Remove listeners\n        removeListeners();\n\n        // Animation is complete, execute callback if there is any\n        if (options.onComplete && typeof options.onComplete === 'function') {\n          options.onComplete(false)\n        }\n      }\n    };\n\n    // Start animating scroll\n    requestID = requestAnimationFrame(step);\n  }\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      module.exports = __ANIMATE_SCROLL_TO;\n      exports = module.exports;\n    }\n    exports.default = __ANIMATE_SCROLL_TO;\n  } else if (window) {\n    window.animateScrollTo = __ANIMATE_SCROLL_TO;\n  }\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}