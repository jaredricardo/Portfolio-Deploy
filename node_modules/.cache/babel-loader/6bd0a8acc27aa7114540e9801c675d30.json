{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBestAnchorGivenScrollLocation = exports.checkElementRelevance = exports.checkLocationRelevance = exports.doesElementContainScrollTop = exports.getElementOffset = exports.getScrollTop = exports.scrollTo = undefined;\n\nvar _animatedScrollTo = require('animated-scroll-to');\n\nvar _animatedScrollTo2 = _interopRequireDefault(_animatedScrollTo);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar scrollTo = exports.scrollTo = function scrollTo(options) {\n  var isIE = /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent);\n\n  if (isIE) {\n    (0, _animatedScrollTo2.default)(options.top, {\n      speed: options.behavior === 'smooth' ? 500 : 0\n    });\n  } else {\n    window.scrollTo(options);\n  }\n};\n\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n}; // get vertical offsets of element, taking scrollTop into consideration\n\n\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _ref = element ? element.getBoundingClientRect() : {\n    top: 0,\n    bottom: 0\n  },\n      top = _ref.top,\n      bottom = _ref.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n}; // does scrollTop live within element bounds?\n\n\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n}; // is el2's location more relevant than el2,\n// parent-child relationship aside?\n\n\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    } // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n\n\n    return bottom2 < bottom1;\n  } // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n\n\n  return top2 > top1;\n}; // check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\n\n\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n\n  return false;\n}; // given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\n\n\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id].component;\n\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};","map":{"version":3,"sources":["/Users/jaredricardo/Desktop/apps/portfolio/node_modules/react-update-url-on-scroll/lib/utils/scroll.js"],"names":["Object","defineProperty","exports","value","getBestAnchorGivenScrollLocation","checkElementRelevance","checkLocationRelevance","doesElementContainScrollTop","getElementOffset","getScrollTop","scrollTo","undefined","_animatedScrollTo","require","_animatedScrollTo2","_interopRequireDefault","obj","__esModule","default","options","isIE","test","navigator","userAgent","top","speed","behavior","window","document","body","scrollTop","documentElement","element","_ref","getBoundingClientRect","bottom","Math","floor","extraOffset","arguments","length","offsetTop","offsetHeight","el1","el2","_getElementOffset","top1","bottom1","_getElementOffset2","top2","bottom2","contains","anchors","offset","bestId","bestElement","keys","forEach","id","component"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBestAnchorGivenScrollLocation = exports.checkElementRelevance = exports.checkLocationRelevance = exports.doesElementContainScrollTop = exports.getElementOffset = exports.getScrollTop = exports.scrollTo = undefined;\n\nvar _animatedScrollTo = require('animated-scroll-to');\n\nvar _animatedScrollTo2 = _interopRequireDefault(_animatedScrollTo);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar scrollTo = exports.scrollTo = function scrollTo(options) {\n  var isIE = /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent);\n\n  if (isIE) {\n    (0, _animatedScrollTo2.default)(options.top, {\n      speed: options.behavior === 'smooth' ? 500 : 0\n    });\n  } else {\n    window.scrollTo(options);\n  }\n};\n\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n};\n\n// get vertical offsets of element, taking scrollTop into consideration\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _ref = element ? element.getBoundingClientRect() : { top: 0, bottom: 0 },\n      top = _ref.top,\n      bottom = _ref.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n};\n\n// does scrollTop live within element bounds?\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n};\n\n// is el2's location more relevant than el2,\n// parent-child relationship aside?\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    }\n    // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n    return bottom2 < bottom1;\n  }\n  // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n  return top2 > top1;\n};\n\n// check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n  return false;\n};\n\n// given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id].component;\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};"]},"metadata":{},"sourceType":"script"}