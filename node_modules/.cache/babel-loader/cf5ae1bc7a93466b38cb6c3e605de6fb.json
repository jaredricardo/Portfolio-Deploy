{"ast":null,"code":"// Production steps of ECMA-262, Edition 6, 22.1.2.1\n// Reference: http://www.ecma-international.org/ecma-262/6.0/#sec-array.from\nmodule.exports = function () {\n  var isCallable = function (fn) {\n    return typeof fn === 'function';\n  };\n\n  var toInteger = function (value) {\n    var number = Number(value);\n\n    if (isNaN(number)) {\n      return 0;\n    }\n\n    if (number === 0 || !isFinite(number)) {\n      return number;\n    }\n\n    return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n  };\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n\n  var toLength = function (value) {\n    var len = toInteger(value);\n    return Math.min(Math.max(len, 0), maxSafeInteger);\n  };\n\n  var iteratorProp = function (value) {\n    if (value != null) {\n      if (['string', 'number', 'boolean', 'symbol'].indexOf(typeof value) > -1) {\n        return Symbol.iterator;\n      } else if (typeof Symbol !== 'undefined' && 'iterator' in Symbol && Symbol.iterator in value) {\n        return Symbol.iterator;\n      } // Support \"@@iterator\" placeholder, Gecko 27 to Gecko 35\n      else if ('@@iterator' in value) {\n          return '@@iterator';\n        }\n    }\n  };\n\n  var getMethod = function (O, P) {\n    // Assert: IsPropertyKey(P) is true.\n    if (O != null && P != null) {\n      // Let func be GetV(O, P).\n      var func = O[P]; // ReturnIfAbrupt(func).\n      // If func is either undefined or null, return undefined.\n\n      if (func == null) {\n        return void 0;\n      } // If IsCallable(func) is false, throw a TypeError exception.\n\n\n      if (!isCallable(func)) {\n        throw new TypeError(func + ' is not a function');\n      }\n\n      return func;\n    }\n  };\n\n  var iteratorStep = function (iterator) {\n    // Let result be IteratorNext(iterator).\n    // ReturnIfAbrupt(result).\n    var result = iterator.next(); // Let done be IteratorComplete(result).\n    // ReturnIfAbrupt(done).\n\n    var done = Boolean(result.done); // If done is true, return false.\n\n    if (done) {\n      return false;\n    } // Return result.\n\n\n    return result;\n  }; // The length property of the from method is 1.\n\n\n  return function from(items\n  /*, mapFn, thisArg */\n  ) {\n    'use strict'; // 1. Let C be the this value.\n\n    var C = this; // 2. If mapfn is undefined, let mapping be false.\n\n    var mapFn = arguments.length > 1 ? arguments[1] : void 0;\n    var T;\n\n    if (typeof mapFn !== 'undefined') {\n      // 3. else\n      //   a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (!isCallable(mapFn)) {\n        throw new TypeError('Array.from: when provided, the second argument must be a function');\n      } //   b. If thisArg was supplied, let T be thisArg; else let T\n      //      be undefined.\n\n\n      if (arguments.length > 2) {\n        T = arguments[2];\n      } //   c. Let mapping be true (implied by mapFn)\n\n    }\n\n    var A, k; // 4. Let usingIterator be GetMethod(items, @@iterator).\n    // 5. ReturnIfAbrupt(usingIterator).\n\n    var usingIterator = getMethod(items, iteratorProp(items)); // 6. If usingIterator is not undefined, then\n\n    if (usingIterator !== void 0) {\n      // a. If IsConstructor(C) is true, then\n      //   i. Let A be the result of calling the [[Construct]]\n      //      internal method of C with an empty argument list.\n      // b. Else,\n      //   i. Let A be the result of the abstract operation ArrayCreate\n      //      with argument 0.\n      // c. ReturnIfAbrupt(A).\n      A = isCallable(C) ? Object(new C()) : []; // d. Let iterator be GetIterator(items, usingIterator).\n\n      var iterator = usingIterator.call(items); // e. ReturnIfAbrupt(iterator).\n\n      if (iterator == null) {\n        throw new TypeError('Array.from requires an array-like or iterable object');\n      } // f. Let k be 0.\n\n\n      k = 0; // g. Repeat\n\n      var next, nextValue;\n\n      while (true) {\n        // i. Let Pk be ToString(k).\n        // ii. Let next be IteratorStep(iterator).\n        // iii. ReturnIfAbrupt(next).\n        next = iteratorStep(iterator); // iv. If next is false, then\n\n        if (!next) {\n          // 1. Let setStatus be Set(A, \"length\", k, true).\n          // 2. ReturnIfAbrupt(setStatus).\n          A.length = k; // 3. Return A.\n\n          return A;\n        } // v. Let nextValue be IteratorValue(next).\n        // vi. ReturnIfAbrupt(nextValue)\n\n\n        nextValue = next.value; // vii. If mapping is true, then\n        //   1. Let mappedValue be Call(mapfn, T, «nextValue, k»).\n        //   2. If mappedValue is an abrupt completion, return\n        //      IteratorClose(iterator, mappedValue).\n        //   3. Let mappedValue be mappedValue.[[value]].\n        // viii. Else, let mappedValue be nextValue.\n        // ix.  Let defineStatus be the result of\n        //      CreateDataPropertyOrThrow(A, Pk, mappedValue).\n        // x. [TODO] If defineStatus is an abrupt completion, return\n        //    IteratorClose(iterator, defineStatus).\n\n        if (mapFn) {\n          A[k] = mapFn.call(T, nextValue, k);\n        } else {\n          A[k] = nextValue;\n        } // xi. Increase k by 1.\n\n\n        k++;\n      } // 7. Assert: items is not an Iterable so assume it is\n      //    an array-like object.\n\n    } else {\n      // 8. Let arrayLike be ToObject(items).\n      var arrayLike = Object(items); // 9. ReturnIfAbrupt(items).\n\n      if (items == null) {\n        throw new TypeError('Array.from requires an array-like object - not null or undefined');\n      } // 10. Let len be ToLength(Get(arrayLike, \"length\")).\n      // 11. ReturnIfAbrupt(len).\n\n\n      var len = toLength(arrayLike.length); // 12. If IsConstructor(C) is true, then\n      //     a. Let A be Construct(C, «len»).\n      // 13. Else\n      //     a. Let A be ArrayCreate(len).\n      // 14. ReturnIfAbrupt(A).\n\n      A = isCallable(C) ? Object(new C(len)) : new Array(len); // 15. Let k be 0.\n\n      k = 0; // 16. Repeat, while k < len… (also steps a - h)\n\n      var kValue;\n\n      while (k < len) {\n        kValue = arrayLike[k];\n\n        if (mapFn) {\n          A[k] = mapFn.call(T, kValue, k);\n        } else {\n          A[k] = kValue;\n        }\n\n        k++;\n      } // 17. Let setStatus be Set(A, \"length\", len, true).\n      // 18. ReturnIfAbrupt(setStatus).\n\n\n      A.length = len; // 19. Return A.\n    }\n\n    return A;\n  };\n}();","map":{"version":3,"sources":["/Users/jaredricardo/Desktop/apps/portfolio/node_modules/array-from/polyfill.js"],"names":["module","exports","isCallable","fn","toInteger","value","number","Number","isNaN","isFinite","Math","floor","abs","maxSafeInteger","pow","toLength","len","min","max","iteratorProp","indexOf","Symbol","iterator","getMethod","O","P","func","TypeError","iteratorStep","result","next","done","Boolean","from","items","C","mapFn","arguments","length","T","A","k","usingIterator","Object","call","nextValue","arrayLike","Array","kValue"],"mappings":"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","sourcesContent":["// Production steps of ECMA-262, Edition 6, 22.1.2.1\n// Reference: http://www.ecma-international.org/ecma-262/6.0/#sec-array.from\nmodule.exports = (function() {\n  var isCallable = function(fn) {\n    return typeof fn === 'function';\n  };\n  var toInteger = function (value) {\n    var number = Number(value);\n    if (isNaN(number)) { return 0; }\n    if (number === 0 || !isFinite(number)) { return number; }\n    return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n  };\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n  var toLength = function (value) {\n    var len = toInteger(value);\n    return Math.min(Math.max(len, 0), maxSafeInteger);\n  };\n  var iteratorProp = function(value) {\n    if(value != null) {\n      if(['string','number','boolean','symbol'].indexOf(typeof value) > -1){\n        return Symbol.iterator;\n      } else if (\n        (typeof Symbol !== 'undefined') &&\n        ('iterator' in Symbol) &&\n        (Symbol.iterator in value)\n      ) {\n        return Symbol.iterator;\n      }\n      // Support \"@@iterator\" placeholder, Gecko 27 to Gecko 35\n      else if ('@@iterator' in value) {\n        return '@@iterator';\n      }\n    }\n  };\n  var getMethod = function(O, P) {\n    // Assert: IsPropertyKey(P) is true.\n    if (O != null && P != null) {\n      // Let func be GetV(O, P).\n      var func = O[P];\n      // ReturnIfAbrupt(func).\n      // If func is either undefined or null, return undefined.\n      if(func == null) {\n        return void 0;\n      }\n      // If IsCallable(func) is false, throw a TypeError exception.\n      if (!isCallable(func)) {\n        throw new TypeError(func + ' is not a function');\n      }\n      return func;\n    }\n  };\n  var iteratorStep = function(iterator) {\n    // Let result be IteratorNext(iterator).\n    // ReturnIfAbrupt(result).\n    var result = iterator.next();\n    // Let done be IteratorComplete(result).\n    // ReturnIfAbrupt(done).\n    var done = Boolean(result.done);\n    // If done is true, return false.\n    if(done) {\n      return false;\n    }\n    // Return result.\n    return result;\n  };\n\n  // The length property of the from method is 1.\n  return function from(items /*, mapFn, thisArg */ ) {\n    'use strict';\n\n    // 1. Let C be the this value.\n    var C = this;\n\n    // 2. If mapfn is undefined, let mapping be false.\n    var mapFn = arguments.length > 1 ? arguments[1] : void 0;\n\n    var T;\n    if (typeof mapFn !== 'undefined') {\n      // 3. else\n      //   a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (!isCallable(mapFn)) {\n        throw new TypeError(\n          'Array.from: when provided, the second argument must be a function'\n        );\n      }\n\n      //   b. If thisArg was supplied, let T be thisArg; else let T\n      //      be undefined.\n      if (arguments.length > 2) {\n        T = arguments[2];\n      }\n      //   c. Let mapping be true (implied by mapFn)\n    }\n\n    var A, k;\n\n    // 4. Let usingIterator be GetMethod(items, @@iterator).\n    // 5. ReturnIfAbrupt(usingIterator).\n    var usingIterator = getMethod(items, iteratorProp(items));\n\n    // 6. If usingIterator is not undefined, then\n    if (usingIterator !== void 0) {\n      // a. If IsConstructor(C) is true, then\n      //   i. Let A be the result of calling the [[Construct]]\n      //      internal method of C with an empty argument list.\n      // b. Else,\n      //   i. Let A be the result of the abstract operation ArrayCreate\n      //      with argument 0.\n      // c. ReturnIfAbrupt(A).\n      A = isCallable(C) ? Object(new C()) : [];\n\n      // d. Let iterator be GetIterator(items, usingIterator).\n      var iterator = usingIterator.call(items);\n\n      // e. ReturnIfAbrupt(iterator).\n      if (iterator == null) {\n        throw new TypeError(\n          'Array.from requires an array-like or iterable object'\n        );\n      }\n\n      // f. Let k be 0.\n      k = 0;\n\n      // g. Repeat\n      var next, nextValue;\n      while (true) {\n        // i. Let Pk be ToString(k).\n        // ii. Let next be IteratorStep(iterator).\n        // iii. ReturnIfAbrupt(next).\n        next = iteratorStep(iterator);\n\n        // iv. If next is false, then\n        if (!next) {\n\n          // 1. Let setStatus be Set(A, \"length\", k, true).\n          // 2. ReturnIfAbrupt(setStatus).\n          A.length = k;\n\n          // 3. Return A.\n          return A;\n        }\n        // v. Let nextValue be IteratorValue(next).\n        // vi. ReturnIfAbrupt(nextValue)\n        nextValue = next.value;\n\n        // vii. If mapping is true, then\n        //   1. Let mappedValue be Call(mapfn, T, «nextValue, k»).\n        //   2. If mappedValue is an abrupt completion, return\n        //      IteratorClose(iterator, mappedValue).\n        //   3. Let mappedValue be mappedValue.[[value]].\n        // viii. Else, let mappedValue be nextValue.\n        // ix.  Let defineStatus be the result of\n        //      CreateDataPropertyOrThrow(A, Pk, mappedValue).\n        // x. [TODO] If defineStatus is an abrupt completion, return\n        //    IteratorClose(iterator, defineStatus).\n        if (mapFn) {\n          A[k] = mapFn.call(T, nextValue, k);\n        }\n        else {\n          A[k] = nextValue;\n        }\n        // xi. Increase k by 1.\n        k++;\n      }\n      // 7. Assert: items is not an Iterable so assume it is\n      //    an array-like object.\n    } else {\n\n      // 8. Let arrayLike be ToObject(items).\n      var arrayLike = Object(items);\n\n      // 9. ReturnIfAbrupt(items).\n      if (items == null) {\n        throw new TypeError(\n          'Array.from requires an array-like object - not null or undefined'\n        );\n      }\n\n      // 10. Let len be ToLength(Get(arrayLike, \"length\")).\n      // 11. ReturnIfAbrupt(len).\n      var len = toLength(arrayLike.length);\n\n      // 12. If IsConstructor(C) is true, then\n      //     a. Let A be Construct(C, «len»).\n      // 13. Else\n      //     a. Let A be ArrayCreate(len).\n      // 14. ReturnIfAbrupt(A).\n      A = isCallable(C) ? Object(new C(len)) : new Array(len);\n\n      // 15. Let k be 0.\n      k = 0;\n      // 16. Repeat, while k < len… (also steps a - h)\n      var kValue;\n      while (k < len) {\n        kValue = arrayLike[k];\n        if (mapFn) {\n          A[k] = mapFn.call(T, kValue, k);\n        }\n        else {\n          A[k] = kValue;\n        }\n        k++;\n      }\n      // 17. Let setStatus be Set(A, \"length\", len, true).\n      // 18. ReturnIfAbrupt(setStatus).\n      A.length = len;\n      // 19. Return A.\n    }\n    return A;\n  };\n})();\n"]},"metadata":{},"sourceType":"script"}